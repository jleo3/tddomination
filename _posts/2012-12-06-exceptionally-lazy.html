---
layout: post
title: "Exceptionally Lazy"
date: 2012-12-06
comments: false
---

<div class='post'>
<head><link href="csharp.css" rel="stylesheet" type="text/css"></link></head>I'm working on a .NET project and have been building an Unhandled Exception Manager in the <a href="http://www.codeproject.com/Articles/7482/User-Friendly-Exception-Handling" target="_blank">spirit of Jeff Atwood's friendly exception handling</a>. If a user encounters an error that will crash our application, the Unhandled Exception Manager steps in first and issues a friendly message. In the background it emails the development team about the exception in as much detail as it can possibly grab.<br /><br />Recently some unwanted functionality gave me the opportunity to learn about lazy evaluation in C#. Look at the following code:<br /><!-- code formatted by http://manoli.net/csharpformat/ --><pre class="csharpcode"><span class="kwrd">return</span> MultiLine(<br /><span class="str">    "Date and Time:         "</span> + DateTime.Now,<br /><span class="str">    "Machine Name:          "</span> + Environment.MachineName,<br /><span class="str">    "IP Address:            "</span> + Dns.GetHostEntry(Dns.GetHostName()).AddressList[0],<br /><span class="str">    "Application Domain:    "</span> + AppDomain.CurrentDomain.FriendlyName,<br />    <span class="str">"Assembly Codebase:     "</span> + _assemblyInfo.CodeBase,<br />    <span class="str">"Assembly Full Name:    "</span> + _assemblyInfo.FullName,<br />    <span class="str">"Assembly Version:      "</span> + _assemblyInfo.Version,<br />    EnhancedStackTrace(<span class="kwrd">new</span> StackTrace(<span class="kwrd">true</span>))<br /> );</pre><br />Multiline simply aggregates the lines so that I can print pretty messages both in the code and in my emails:<br /><br /><!-- code formatted by http://manoli.net/csharpformat/ --><pre class="csharpcode"><span class="kwrd">static</span> <span class="kwrd">string</span> MultiLine(<span class="kwrd">params</span> <span class="kwrd">string</span>[] args)<br />{<br /><span class="kwrd">    return</span> <span class="kwrd">string</span>.Join(Environment.NewLine, args);<br />}</pre><br />If any one of these nested calls throws an exception, we get an <b>unhandled exception</b> in the <b>unhandled exception manager</b>. Not good. Wrapping the whole thing in a <span style="font-family: Courier New, Courier, monospace;">try/catch</span> prevents this but will not give us the maximum amount of information. If <span style="font-family: Courier New, Courier, monospace;">Dns.GetHostName</span> returns null, for example, it would still be nice to get the <span style="font-family: Courier New, Courier, monospace;">MachineName </span>and assembly information. The following MSpec test illustrates the problem:<br /><br /><!-- code formatted by http://manoli.net/csharpformat/ --> <br /><pre class="csharpcode">[Subject(<span class="kwrd">typeof</span> (ExceptionMessageBuilder), <span class="str">"SystemInfo"</span>)]<br /><span class="kwrd">class</span> when_an_exception_is_thrown : ExceptionMessageBuilderSpec<br />{<br /><span class="kwrd">    private</span> <span class="kwrd">static</span> Exception Exception;<br />    <span class="kwrd">private</span> <span class="kwrd">static</span> Version Version;<br /><br />    <span class="kwrd">private</span> Establish context = () =&gt;<br />        {<br />            Exception = <span class="kwrd">new</span> Exception();<br />            Version = <span class="kwrd">new</span> Version(1, 0, 0, 254);<br />            AssemblyInfo.WhenToldTo(x =&gt; x.FullName).Throw(Exception);<br />            AssemblyInfo.WhenToldTo(x =&gt; x.Version).Return(Version);<br />        };<br /><br />    <span class="kwrd">private</span> It will_handle_the_exception = () =&gt; ExceptionMessageBuilder.SystemInfo();<br />}</pre><br />I was able to make this test pass and extract the maximum amount of information about my application crash using lazy evaluation:<br /><br /><!-- code formatted by http://manoli.net/csharpformat/ --> <br /><pre class="csharpcode"><span class="kwrd">public</span> <span class="kwrd">string</span> SystemInfo()<br />{<br /><span class="kwrd">    return</span> MultiLazy(<span class="kwrd">new</span> List&lt;Lazy&lt;<span class="kwrd">string</span>&gt;&gt;<br />        {<span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"Date and Time:         "</span> + AppDomain.CurrentDomain.FriendlyName),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"Machine Name:          "</span> + Environment.MachineName),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"IP Address:            "</span> + Dns.GetHostEntry(Dns.GetHostName()).AddressList[0]),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"Application Domain:    "</span> + AppDomain.CurrentDomain.FriendlyName),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"Assembly Codebase:     "</span> + _assemblyInfo.CodeBase),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"Assembly Full Name:    "</span> + _assemblyInfo.FullName),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; <span class="str">"Assembly Version:      "</span> + _assemblyInfo.Version),<br />         <span class="kwrd">new</span> Lazy&lt;<span class="kwrd">string</span>&gt;(() =&gt; EnhancedStackTrace(<span class="kwrd">new</span> StackTrace(<span class="kwrd">true</span>)))<br />     });<br />}</pre><br />Using the <span style="font-family: Courier New, Courier, monospace;">Lazy&lt;&gt;</span> syntax, I can state my intentions without executing any of the code. Instead, the CLR compiles the code and waits for <span style="font-family: Courier New, Courier, monospace;">.Value</span> to be called on the arguments before executing. &nbsp;A change to our <span style="font-family: Courier New, Courier, monospace;">MultiLine </span>function demonstrates this in action:<br /><br /><!-- code formatted by http://manoli.net/csharpformat/ --> <br /><pre class="csharpcode"><span class="kwrd">static</span> <span class="kwrd">string</span> MultiLazy(List&lt;Lazy&lt;<span class="kwrd">string</span>&gt;&gt; args)<br />{<br /><span class="kwrd">    var</span> stringBuilder = <span class="kwrd">new</span> StringBuilder();<br />    <span class="kwrd">foreach</span> (<span class="kwrd">var</span> arg <span class="kwrd">in</span> args)<br />    {<br />        <span class="kwrd">try</span><br />        {<br />            stringBuilder.Append(arg.Value);<br />        }<br /><span class="rem">// ReSharper disable EmptyGeneralCatchClause -- we want all the information we can get.</span><br />        <span class="kwrd">catch</span> (Exception) {}<br /><span class="rem">// ReSharper restore EmptyGeneralCatchClause</span><br />        }<br />        <span class="kwrd">return</span> stringBuilder.ToString();<br />}</pre><br />Of course, this is my first attempt at lazy evaluation in C# and I'm open to other methods. Could this be cleaned up? Are there better approaches out there?<br /><br /></div>
