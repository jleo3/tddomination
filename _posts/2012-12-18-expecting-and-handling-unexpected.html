---
layout: post
title: "Expecting (and Handling) the Unexpected"
date: 2012-12-18
comments: false
---

<div class='post'>
In <a href="http://testdrivendomination.blogspot.com/2012/12/exceptionally-lazy.html" target="_blank">an earlier post</a> I mentioned that I'm creating an unhandled exception manager inspired by <a href="http://www.codeproject.com/Articles/7482/User-Friendly-Exception-Handling" target="_blank">Jeff Atwood's Friendly Exception Manager</a>. A couple of days ago we found a bug that crashed our application in UAT. Much to my dismay, no friendly exception message whatsoever was displaying for the user under these circumstances. But how could this be? I'm catching all unhandled exceptions for this very purpose!<br /><br />Or am I? As it turns out, I was catching most, but not all, types of unhandled exceptions. Here's where I started:<br /><pre class="csharpcode">        <span class="kwrd">public</span> <span class="kwrd">void</span> AddHandler()<br />        {<br />            Application.ThreadException += ThreadExceptionHandler;<br />        }</pre><pre class="csharpcode"></pre>This is pretty simple and is ideally the first method called in your application after initializing your unhandled exception manager. (Those intimately familiar with Jeff Atwood's version will notice that his exception managers are purely static. None of my objects are static and there are all kinds of interfaces and small helper objects in place, but the spirit remains the same.) The ThreadException event deals specifically with the UI thread. The handler is where the user notification takes place. However, there are two items that are unaccounted for.<br /><br />First, my application is a combination of WPF and WinForms. The unhandled exception that crashed our application occurred in WinForms. Windows Forms errors do not behave the same way as ThreadExceptions by default and need to be told what to do.&nbsp;MSDN does&nbsp;<a href="http://msdn.microsoft.com/en-us/library/system.windows.forms.application.setunhandledexceptionmode(v=vs.100).aspx" target="_blank">a nice job of illustrating</a>&nbsp;this somewhat confusing concept.&nbsp;The second thing I neglected was defining the behavior of non-UI thread exceptions. Our application relies heavily on the <a href="http://msdn.microsoft.com/en-us/library/dd460717.aspx" target="_blank">TPL library</a>&nbsp;which gives us a big reason to be concerned with non-UI thread behavior. Luckily, we can relatively easily handle everything listed above with a few lines of code and an extra event handler (which, in my case, mirrors the functionality of the handler discussed above). The finished code looks like this:<br /><pre class="csharpcode">        <span class="kwrd">public</span> <span class="kwrd">void</span> AddHandler()<br />        {<br />            Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);<br />            AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionHandler;<br />            Application.ThreadException += ThreadExceptionHandler;<br />        }</pre></div>
